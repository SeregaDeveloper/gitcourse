Настройка параметров для работы с удаленным репозиторием:

- Укажем имя пользователя: 
```
git config --global user.name SeregaDeveloper
```

- Укажем почту:
``` 
git config --global user.email seregamalinovsky68@gmail.com
```

Все глобальные настройки Git хранит в файле `.gitconfig` в домашней директории. Команда запишет в этот файл указанные имя и почту. Чтобы убедиться в этом, можно вызвать команду для чтения файлов.
``` bash
cat ~/.gitconfig 
```

Другой способ проверки — вывести содержимое файла конфигурации Git той же командой `git config` с флагом `--list` (англ. «список»).
```
git config --list 
```

 Сделать папку репозиторием:
``` 
git init
```

«Разгитить» папку, если что-то пошло не так:
``` 
rm -rf .git
``` 

! Будьте осторожны: в подпапке `.git` хранится история изменений. Если удалить `.git`, то вся история проекта будет стёрта без возможности восстановления — останется только последняя версия файлов.

Проверить состояние репозитория:
``` 
git status
``` 

Подготовить файлы к сохранению:
``` 
git add
```

Ключ, или флаг, `--all` позволяет подготовить к сохранению все файлы в репозитории:
``` 
git add --all
``` 

! Команда `git add` не сохраняет содержимое файлов в репозитории. Само сохранение, или фиксацию состояния файлов, называют **коммитом** (от англ. _commit_ — «совершать», «фиксировать»). «Сделать коммит» значит сохранить текущую версию файла.

Коммит — это одна из основных сущностей в Git (и в других системах контроля версий). Коммит гарантирует, что изменения будут сохранены в истории и при необходимости к ним можно будет «откатиться». Это как если бы вы могли выполнить операцию `Ctrl+Z` для целой папки (репозитория).

Выполнить коммит: 
``` 
git commit -m 'Мой первый коммит!' 
```

Просмотреть историю коммитов: 
``` 
git log
``` 

### Инструкция по созданию репозитория на GitHub

1. Зайдите в свой профиль по ссылке `https://github.com/username`, где `username` — имя, которое вы указали при регистрации. Эта страница — презентация вас и ваших проектов. Её видят другие пользователи. Надпись **You don't have any public repositories yet** (англ. «у вас пока нет публичных репозиториев») сообщает, что пока у вас нет проектов.

![](https://pictures.s3.yandex.net/resources/S1_02_03-1-2_1684935796.png)

2. Создайте репозиторий. Для этого перейдите на вкладку **Repositories** (англ. «репозитории»), а затем нажмите на зелёную кнопку **New** (англ. «новый») справа.

![](https://pictures.s3.yandex.net/resources/S1_02_03-3_1684935815.png)

3. Открылось окно создания нового репозитория. Назовите его `first-project`. Название удалённого репозитория необязательно должно совпадать с именем папки проекта у вас на компьютере. Но чтобы не путаться, будем называть их одинаково. Другие поля вам пока не понадобятся. Смело нажимайте на зелёную кнопку **Create repository** (англ. «создать репозиторий») внизу.

![](https://pictures.s3.yandex.net/resources/S1_02_03-3-2_1684935833.png)

Готово! Удалённый репозиторий создан. Страница с ним открывается автоматически.

![](https://pictures.s3.yandex.net/resources/S1_02_03-2-3_1684935849.png)

Осталось связать удалённый репозиторий с локальным, который уже есть на вашем компьютере. GitHub предоставляет для этого инструкцию (пункт `…or push an existing repository from the command line`).

Но прежде, чтобы упростить работу с GitHub и сделать её более безопасной, вы научитесь генерировать **SSH-ключи** (от англ. _**S**ecure **Sh**ell_ — «безопасная оболочка»). Об этом в следующем уроке.

### Инструкция по генерации SSH-ключа

1. Для генерации SSH-пары можно использовать программу `ssh-keygen`. Откройте терминал и введите следующую команду.
```
$ ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

Используйте электронную почту, к которой привязан ваш GitHub-аккаунт.

Если вы видите сообщение об ошибке, то, скорее всего, ваша система не поддерживает алгоритм шифрования `ed25519`. Ничего страшного: используйте другой алгоритм.
```
$ ssh-keygen -t rsa -b 4096 -C "электронная почта, к которой привязан ваш аккаунт на GitHub" 
```

После ввода отобразится такое сообщение:
```
> Generating public/private rsa key pair. # сгенерированы публичный и приватный ключи 
```

2. Укажите место хранения ключей. Простой вариант — сделать домашний каталог пользователя путём по умолчанию. Для этого нажмите `Enter`.

**macOS:**
```
> Enter a file in which to save the key (/Users/you/.ssh/id_rsa): [Press enter] 
```

**Windows**:
```
> Enter a file in which to save the key (C:\Users\<имя_пользователя>\.ssh\):[Press enter] 
```

Теперь в указанной директории появится пара ключей.

3. Программа запросит **кодовую фразу** (англ. _passphrase_) для доступа к SSH-ключу. Вы можете оставить поле пустым. Для этого нажмите `Enter`, а затем ещё раз `Enter` для подтверждения.
``` 
> Enter passphrase (empty for no passphrase): [Type a passphrase]
> Enter same passphrase again: [Type passphrase again] 
```

! Применение кодовой фразы усиливает безопасность ключей. Если вы используете эту фразу, ключ будет надёжно защищён в случае несанкционированного доступа к вашему компьютеру.

4. Готово! Теперь осталось проверить, что ключи действительно сгенерировались. Для этого вызовите эту команду:

``` bash
ls -a ~/.ssh
```

### Инструкция по связыванию SSH-ключа и GitHub-аккаунта

1. После выполнения команды `ssh-keygen` из предыдущего урока в директории `~/.ssh` будет создано два файла — `id_ed25519` и `id_ed25519.pub` (или `id_rsa` и `id_rsa.pub` — в зависимости от того, какой алгоритм вы использовали):
    - `id_ed25519`/`id_rsa` — приватный ключ (файл без `.pub` в конце). Ни в коем случае не копируйте его и не делитесь им.
    - `id_ed25519.pub`/`id_rsa.pub` — публичный ключ (на это указывает расширение `.pub`).
        
        Скопируйте содержимое файла с публичным ключом в буфер обмена.

**macOS**:
``` bash
# скопировать содержимое ключа в буфер обмена:
$ pbcopy < ~/.ssh/id_rsa.pub
# для ed25519:
$ pbcopy < ~/.ssh/id_ed25519.pub 
```

Здесь используется команда `pbcopy` — она копирует поток данных в буфер обмена. Запись `pbcopy < ~/.ssh/id_rsa.pub` означает: «Скопируй в буфер обмена всё содержимое файла `~/.ssh/id_rsa.pub`».

В качестве альтернативы вы можете распечатать файл на экран с помощью `cat ~/.ssh/id_rsa.pub` и скопировать его вручную.

**Windows:**
```
# скопировать содержимое ключа в буфер обмена:
$ clip < ~/.ssh/id_rsa.pub
# для ed25519:
$ clip < ~/.ssh/id_ed25519.pub 
```

Если `clip` не сработает, выведите содержимое файла с помощью `cat ~/.ssh/id_rsa.pub` или `cat ~/.ssh/id_ed25519.pub` и скопируйте вывод в буфер обмена из консоли.

2. Перейдите на GitHub и выберите пункт **Settings** (англ. «настройки») в меню аккаунта.

![](https://pictures.s3.yandex.net/resources/M2_T4_03_01_1685016747.png)

3. В меню слева нажмите на пункт **SSH and GPG keys**.

![](https://pictures.s3.yandex.net/resources/M2_T4_03_02_1685016772.png)

4. В открывшейся вкладке выберите **New SSH key** (англ. «новый SSH-ключ»).

![](https://pictures.s3.yandex.net/resources/M2_T4_03_03_1685016795.png)

5. В поле **Title** (англ. «заголовок») напишите название ключа. Например, **Personal key** (англ. «личный ключ»).
6. В поле **Key type** (англ. «тип ключа») должно быть **Authentication Key** (англ. «ключ аутентификации»).
7. В поле **Key** скопируйте ваш ключ из буфера обмена.

![](https://pictures.s3.yandex.net/resources/M2_T4_03_04_1685016816.png)

8. Нажмите на кнопку **Add SSH key** (англ. «добавить SSH-ключ»).

![](https://pictures.s3.yandex.net/resources/M2_T4_03_05_1685016840.png)

9. Проверьте правильность ключа с помощью следующей команды.
``` bash
$ ssh -T git@github.com 
```

Если это первый раз, когда вы используете Git, чтобы поделиться проектом на GitHub, появится похожее предупреждение.
```
The authenticity of host 'github.com (140.82.121.4)' can't be established. ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU. This key is not known by any other names. Are you sure you want to continue connecting (yes/no/[fingerprint])? 
```

Это предупреждение сообщает, что вы никогда не соединялись с сервером GitHub. Поэтому Git не может гарантировать, что сервер является тем, за кого он себя выдаёт.

Для подтверждения подлинности сервер генерирует и публикует ключи SHA256. Вы можете проверить ключи GitHub [по этой ссылке](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/githubs-ssh-key-fingerprints). Если ключ в предупреждении совпадает с тем, что вы видите на сайте, значит, сервер является действительным. Введите `yes`, чтобы продолжить. Вы увидите приветствие на экране.

```
Hi %ВАШ_АККАУНТ%! You've successfully authenticated, but GitHub does not provide shell access. 
```

Привязать удалённый репозиторий к локальному: 
```
git remote add
```

Перейдите на страницу удалённого репозитория, выберите тип `SSH` и скопируйте URL. Кнопка справа позволит сделать это мгновенно:
```
git remote add origin git@github.com:SeregaDeveloper/yandex_practise.git
```

Отправить изменения на удалённый репозиторий: 
```
git push
```

### Шпаргалка markdown

## Выделение текста

Вы можете выделять текст в markdown с помощью символов `_` или `*`. Например:

Пример _курсива_ и **жирного** текста.

#### Заголовки

Заголовки можно создавать с помощью символа `#`. Чем больше `#`, тем меньше заголовок. Например:

# Заголовок первого уровня
## Заголовок второго уровня
### Заголовок третьего уровня

#### Выделение кода

Чтобы выделить текст как код, поместите его в тройные кавычки `````. 

```
mkdir my_project
cd my_project
git init
```

### Хеш — основной идентификатор коммита

Git хранит таблицу соответствий `хеш → информация о коммите`. Если вы знаете хеш, вы можете узнать всё остальное: автора и дату коммита и содержимое закоммиченных файлов. Можно сказать, что хеш — основной идентификатор коммита.

Все хеши и таблицу `хеш → информация о коммите` Git сохраняет в служебные файлы. Они находятся в скрытой папке `.git` в репозитории проекта.

Git преобразует информацию о коммитах с помощью алгоритма SHA-1

### Получить сокращённый лог — `git log --oneline`


### Файл `HEAD`

Файл `HEAD` (англ. «голова», «головной») — один из служебных файлов папки `.git`. Он указывает на коммит, который сделан последним (то есть на самый новый).

Внутри `HEAD` — ссылка на служебный файл: `refs/heads/master` (или `refs/heads/main` в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита.

Когда вы делаете коммит, Git обновляет `refs/heads/master` — записывает в него хеш последнего коммита. Получается, что `HEAD` тоже обновляется, так как ссылается на `refs/heads/master`.

### Статусы `untracked`/`tracked`, `staged` и `modified`

Одна из ключевых задач Git — отслеживать изменения файлов в репозитории. Для этого каждый файл помечается каким-либо статусом. Рассмотрим основные.

- **`untracked`** (англ. «неотслеживаемый»)  
    Мы говорили, что новые файлы в Git-репозитории помечаются как `untracked`, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У `untracked`-файла нет предыдущих версий, зафиксированных в коммитах или через команду `git add`.
- **`staged`** (англ. «подготовленный»)
    
    После выполнения команды `git add` файл попадает в **staging area** (от англ. _stage_ — «сцена», «этап [процесса]» и _area_ — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии `staged`.
    
    В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда `git add` добавляет персонажей (текущее содержимое файла или нескольких файлов) на **сцену** (англ. _stage_) для общей фотографии, а `git commit` делает снимок всей сцены целиком.
- **`tracked`** (англ. «отслеживаемый»)  
    Состояние `tracked` — это противоположность `untracked`. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью `git commit`, а также файлы, которые были добавлены в staging area командой `git add`. То есть все файлы, в которых Git так или иначе отслеживает изменения.
- **`modified`** (англ. «изменённый»)  
    Состояние `modified` означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён.

### Про `staged` и `modified`

Команда `git add` добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете `git add file.txt`, а затем измените `file.txt`, то новое содержимое файла не будет находиться в staging.

Git сообщит об этом с помощью статуса `modified`: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить `git add file.txt` ещё раз.

Без единообразия коммитов нет и эффективной работы в Git. Это может показаться мелочью, но когда коммиты с сообщениями в разных стилях идут друг за другом, их может быть сложно читать.

Чтобы упростить работу, команды или даже целые компании часто договариваются об определённом стиле (то есть о правилах) оформления сообщений коммитов.

Например, правила могут быть такие:

- длина сообщения от 3030 до 7272 символов;
- первое слово — глагол в инфинитиве («исправить», «дополнить», «добавить» и другие);
- и так далее.

### Корпоративный

Во многих компаниях применяется Jira — система для организации проектов и задач. У каждой задачи в Jira есть идентификатор из нескольких заглавных латинских букв и номера. Например, `LGS-239` значит, что это 239239-я задача в проекте **LGS** (сокращение от англ. _**l**o**g**istic**s**_ — «логистика»).

В корпоративном стиле в начале сообщения обычно указывают Jira-ID, а после — текст сообщения.

Скопировать кодBASH

```
$ git commit -m "LGS-239: Дополнить список пасхалок новыми числами" 
```

Стандарт **Conventional Commits** (англ. «соглашение о коммитах») отличается качественной документацией и подробной проработкой. Он подходит для репозиториев с исходным кодом программ. Использовать его для других типов проектов (например, для перевода книги) было бы неудобно.

Conventional Commits предлагает такой формат коммита: `<type>: <сообщение>`. Первая часть `type` — это тип изменений. Таких типов достаточно много. Вот два примера:

- `feat` (сокращение от англ. _feature_) — для новой функциональности;
- `fix` (от англ. «исправить», «устранить») — для исправленных ошибок.

Более подробный список можно увидеть [на сайте с описанием этого стиля](https://www.conventionalcommits.org/ru/v1.0.0-beta.4/#%D1%81%D0%BF%D0%B5%D1%86%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F).

Например, сообщение может быть таким.

Скопировать кодBASH

```
git commit -m "feat: добавить подсчёт суммы заказов за неделю" 
```

### GitHub-стиль

GitHub можно использовать не только для хранения файлов проекта, но и для ведения списка **задач** (англ. _issue_) этого проекта. Если коммит «закрывает» или «решает» какую-то задачу, то в его сообщении удобно указывать ссылку на неё. Для этого в любом месте сообщения нужно указать `#<номер задачи>`. Например, вот так.

Скопировать кодBASH

```
$ git commit -m "Исправить #334, добавить график температуры" 
```

В таком случае GitHub свяжет коммит и задачу.
